import sys
sys.path.append("..")
import json
from app.pia_llm import get_pia_response
from evaluator.llm_evaluator import correctness
from evaluator.tool_evaluator import evaluate_tools
import uuid
import argparse
import csv
import os
import asyncio

parser = argparse.ArgumentParser()
parser.add_argument("--qa_pairs_path", type=str, default="../qa_pairs/sales_query")
parser.add_argument("--graph_data_path", type=str, default="../graph_data/sales_query.json") 
parser.add_argument("--output_path", type=str, default="logs/results.csv")
# parser.add_argument("--base_url", type=str, default="http://34.44.20.192:8001/api")

args = parser.parse_args()


def save_result(result: dict, output_path: str):
    with open(output_path, "a") as f:
        writer = csv.writer(f)
        writer.writerow(result.values())
    
def load_messages(message_path: str) -> dict:
    """
    Load the user messages from the given path.
    """
    merged_data = []
    for file in os.listdir(message_path):
        with open(os.path.join(message_path, file), "r") as f:
            message_data = json.load(f)
            merged_data.extend(message_data)
    return merged_data

def response_generator(session_id: str, user_message: str, graph_data: dict) -> tuple:
    """
    Generate responses for the given user messages.
    
    Args:
        base_url (str): The base URL for the PIA API.
        session_id (str): The session ID for the PIA API.
        user_message (str): The user message to generate a response for.
        graph_data (dict): The graph data for the PIA API.
    Returns:
        dict: The response from the PIA API.
        list: The tools generated by the PIA API.
    """
    response, tools = asyncio.run(get_pia_response(session_id, user_message, graph_data))
    return response, tools

def main():
    """
    Main function to run the PIA evaluator.
    """
    user_messages = [key_value_pair["question"] for key_value_pair in load_messages(args.qa_pairs_path)]
    ground_truths = [key_value_pair["answer"] for key_value_pair in load_messages(args.qa_pairs_path)]
    ground_tool_names = [key_value_pair["tool_call"] for key_value_pair in load_messages(args.qa_pairs_path)]
    with open(args.output_path, "w") as f:
        writer = csv.writer(f)
        writer.writerow(["Question", "Ground Truth", "LLM Response", "Ground Tool", "Tool Called", "Response Correctness", "Tool Correctness"])
    for user_message, ground_truth, ground_tool_name in zip(user_messages, ground_truths, ground_tool_names):
        session_id = str(uuid.uuid4())
        response, tool_response = response_generator(session_id, user_message, args.graph_data_path)
        correctness_result = correctness(user_message, ground_truth, response)
        tool_result, tool_names = evaluate_tools(tool_response, ground_tool_name)
        result = {
            "Question": user_message,
            "Ground Truth": ground_truth,
            "LLM Response": response,
            "Ground Tool": ground_tool_name,
            "Tool Called": tool_names,
            "Response Correctness": correctness_result,
            "Tool Correctness": tool_result
        }
        save_result(result, args.output_path)


if __name__ == "__main__":
    main()
